<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Hunt Trainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .letter-cell {
            width: 60px; height: 60px; border: 1px solid #ccc; display: flex;
            justify-content: center; align-items: center; font-size: 1.5rem;
            font-weight: bold; text-transform: uppercase; cursor: default; /* Default cursor */
            user-select: none; transition: background-color 0.2s ease; border-radius: 0.375rem;
            background-color: white; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
        }
        .letter-input {
            width: 90%; height: 90%; text-align: center; font-size: 1.5rem;
            font-weight: bold; text-transform: uppercase; border: none;
            outline: none; background-color: transparent; padding: 0; margin: 0; border-radius: 0.375rem;
        }
        .selected { background-color: #60a5fa; color: white; } /* bg-blue-400 */
        .last-selected { background-color: #2563eb; color: white; } /* bg-blue-600 */
        #game-grid {
            display: grid; gap: 0.5rem; touch-action: none;
            justify-content: center; margin: auto; transition: box-shadow 0.3s ease; /* Added for flash */
        }
        /* Allow clicking/dragging on populated cells only when game running */
        .letter-cell.game-running:not(:has(input)) { cursor: pointer; }
        #message-area { min-height: 2rem; transition: all 0.3s ease-in-out; opacity: 1; }
        #found-words-list::-webkit-scrollbar { width: 8px; }
        #found-words-list::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #found-words-list::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #found-words-list::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Flash effect styles */
        .flash-success { box-shadow: 0 0 15px 5px rgba(74, 222, 128, 0.7); } /* Green glow */
        .flash-error { box-shadow: 0 0 15px 5px rgba(248, 113, 113, 0.7); } /* Red glow */
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Word Hunt Trainer</h1>

        <div id="settings-area" class="flex flex-wrap justify-center items-center gap-4 mb-6">
            <div>
                <label for="grid-size" class="text-sm font-medium text-gray-700 mr-2">Grid Size (NxN):</label>
                <input type="number" id="grid-size" value="4" min="3" max="6" class="w-16 p-1 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div>
                <label for="time-limit" class="text-sm font-medium text-gray-700 mr-2">Time (seconds):</label>
                <input type="number" id="time-limit" value="90" min="10" step="10" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
            <button id="apply-settings" class="px-4 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 shadow-sm">Apply Settings</button>
        </div>

        <div class="flex flex-col md:flex-row gap-6">
            <div class="flex-1 flex flex-col items-center">
                <div id="game-grid" class="mb-4 p-1 rounded-lg"></div>

                 <div class="mb-4 text-center">
                    <span class="text-lg font-medium text-gray-700">Current Word:</span>
                    <span id="current-word-display" class="text-xl font-bold text-blue-600 ml-2 h-8 inline-block min-w-[100px] border-b-2 border-gray-300 align-bottom"></span>
                </div>

                <div class="flex flex-wrap justify-center gap-3 mb-4">
                    <button id="start-game" class="px-5 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 shadow-md font-semibold">Start Game</button>
                    <button id="submit-word" class="px-5 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500 shadow-md font-semibold" disabled>Submit Word</button>
                    <button id="reset-current-game" class="px-5 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 shadow-md font-semibold">Stop</button>
                    <button id="clear-board" class="px-5 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 shadow-md font-semibold">Clear</button>
                </div>
                 <div id="message-area" class="text-center font-medium mb-4 h-6"></div>
            </div>

            <div class="w-full md:w-1/3 bg-gray-50 p-4 rounded-lg shadow-inner flex flex-col">
                <div class="text-center mb-4">
                    <div class="text-lg font-semibold text-gray-700">Time Left</div>
                    <div id="timer-display" class="text-4xl font-bold text-blue-600">0</div>
                </div>
                <div class="text-center mb-4">
                    <div class="text-lg font-semibold text-gray-700">Score</div>
                    <div id="score-display" class="text-4xl font-bold text-green-600">0</div>
                </div>
                <div class="flex-1 flex flex-col min-h-0">
                     <h3 class="text-lg font-semibold text-gray-700 text-center mb-2">Found Words (<span id="word-count">0</span>)</h3>
                    <div id="found-words-list" class="flex-1 overflow-y-auto bg-white border border-gray-200 rounded-md p-2 text-sm space-y-1"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        // Select multiple elements more concisely
        const getEl = id => document.getElementById(id);
        const gridContainer = getEl('game-grid');
        const gridSizeInput = getEl('grid-size');
        const timeLimitInput = getEl('time-limit');
        const applySettingsButton = getEl('apply-settings');
        const startGameButton = getEl('start-game');
        const submitWordButton = getEl('submit-word');
        const resetCurrentGameButton = getEl('reset-current-game');
        const clearBoardButton = getEl('clear-board');
        const currentWordDisplay = getEl('current-word-display');
        const timerDisplay = getEl('timer-display');
        const scoreDisplay = getEl('score-display');
        const foundWordsList = getEl('found-words-list');
        const wordCountDisplay = getEl('word-count');
        const messageArea = getEl('message-area');
        const settingsArea = getEl('settings-area');
        const bodyElement = document.body;

        // --- Game State ---
        let gridSize = parseInt(gridSizeInput.value);
        let timeLimit = parseInt(timeLimitInput.value);
        let timeLeft = timeLimit;
        let score = 0;
        let timerInterval = null;
        let isGameRunning = false;
        let currentSelection = []; // {row, col, letter}
        let currentPath = []; // Cell elements
        let foundWords = new Set();
        let isDragging = false;
        let gridLetters = []; // 2D array of letters on board
        let cells = []; // 1D array of cell elements
        let messageTimeout; // For flash messages

        // --- Constants ---
        const LETTER_FREQUENCIES = "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOPPQRRRRRRSSSSSSTTTTTTTUUUUVVWWXYYZ";
        const DICTIONARY_API_URL = "https://api.dictionaryapi.dev/api/v2/entries/en/";
        const SCORE_MAP = { 3: 100, 4: 400, 5: 800, 6: 1400, 7: 1800, 8: 2200 };

        // --- Functions ---

        const getRandomLetter = () => {
            const letter = LETTER_FREQUENCIES[Math.floor(Math.random() * LETTER_FREQUENCIES.length)];
            return letter === 'Q' ? 'Q' : letter; // Store 'Q' internally
        };

        const createGrid = () => {
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 60px)`;
            gridContainer.classList.remove('game-running', 'flash-success', 'flash-error'); // Clear classes
            cells = [];
            gridLetters = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'letter-cell'; // Use className for simplicity
                    cell.dataset.row = r; cell.dataset.col = c;

                    const input = document.createElement('input');
                    input.className = 'letter-input';
                    input.type = 'text'; input.maxLength = 1;
                    input.dataset.row = r; input.dataset.col = c;

                    input.addEventListener('input', (e) => {
                        let value = e.target.value.toUpperCase().slice(0, 1);
                        e.target.value = value;
                        gridLetters[r][c] = /^[A-Z]$/.test(value) ? value : '';
                    });
                    input.addEventListener('keydown', handleInputKeyDown);

                    cell.appendChild(input);
                    gridContainer.appendChild(cell);
                    cells.push(cell);
                }
            }
        };

        const handleInputKeyDown = (e) => {
            if (isGameRunning || !['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
            e.preventDefault();
            const input = e.target;
            const r = parseInt(input.dataset.row);
            const c = parseInt(input.dataset.col);
            let nr = r, nc = c;

            if (e.key === 'ArrowUp') nr = Math.max(0, r - 1);
            else if (e.key === 'ArrowDown') nr = Math.min(gridSize - 1, r + 1);
            else if (e.key === 'ArrowLeft') nc = Math.max(0, c - 1);
            else if (e.key === 'ArrowRight') nc = Math.min(gridSize - 1, c + 1);

            const nextInput = gridContainer.querySelector(`.letter-input[data-row='${nr}'][data-col='${nc}']`);
            if (nextInput) { nextInput.focus(); nextInput.select(); }
        };

        const populateGrid = () => {
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                let letter = gridLetters[r][c];

                if (!letter || !/^[A-Z]$/.test(letter)) {
                    letter = getRandomLetter();
                    gridLetters[r][c] = letter;
                }
                const displayLetter = (letter === 'Q') ? 'Qu' : letter;
                cell.innerHTML = displayLetter;
                cell.dataset.letter = letter;
                cell.classList.add('game-running');
            });
            gridContainer.classList.add('game-running');
        };

        const updateCurrentWordDisplay = () => {
            const word = currentSelection.map(item => item.letter).join('');
            currentWordDisplay.textContent = word.replace(/Q/g, 'QU');

            submitWordButton.disabled = word.length < 3 || !isGameRunning;
            // Reset/Clear buttons are generally enabled, disable handled elsewhere if needed (like API call)
            resetCurrentGameButton.disabled = false;
            clearBoardButton.disabled = false;

            cells.forEach(cell => cell.classList.remove('selected', 'last-selected'));
            currentPath.forEach((cell, index) => {
                cell.classList.add('selected');
                if (index === currentPath.length - 1) cell.classList.add('last-selected');
            });
        };

        const areCellsAdjacent = (cell1, cell2) => {
            if (!cell1 || !cell2) return false;
            const r1 = parseInt(cell1.dataset.row), c1 = parseInt(cell1.dataset.col);
            const r2 = parseInt(cell2.dataset.row), c2 = parseInt(cell2.dataset.col);
            return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1 && !(r1 === r2 && c1 === c2);
        };

        const handleCellClick = (event) => {
            if (!isGameRunning || isDragging) return;
            const cell = event.target.closest('.letter-cell');
            if (!cell || !cell.dataset.letter) return;

            const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col), letter = cell.dataset.letter;
            const lastCell = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
            const existingIndex = currentSelection.findIndex(item => item.row === r && item.col === c);

            if (existingIndex !== -1) { // Cell already selected
                if (existingIndex === currentSelection.length - 1) { // Click last: deselect
                    currentSelection.pop(); currentPath.pop();
                } else { flashMessage("Cannot reuse letters out of sequence.", "error"); return; }
            } else { // New cell
                if (!lastCell || areCellsAdjacent(lastCell, cell)) { // Check adjacency
                    currentSelection.push({ row: r, col: c, letter }); currentPath.push(cell);
                } else { flashMessage("Letters must be adjacent.", "error"); return; }
            }
            updateCurrentWordDisplay();
        };

        // --- Touch/Drag Handling ---
        const getCellFromPoint = (x, y) => {
            const el = document.elementFromPoint(x, y);
            return el ? el.closest('.letter-cell') : null;
        };

        const handleDragStart = (event) => {
            if (!isGameRunning) return;
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const startCell = getCellFromPoint(clientX, clientY);

            if (startCell && startCell.dataset.letter) {
                isDragging = true;
                clearSelection();
                if (event.cancelable && event.type.startsWith('touch')) event.preventDefault();
                const r = parseInt(startCell.dataset.row), c = parseInt(startCell.dataset.col), letter = startCell.dataset.letter;
                currentSelection.push({ row: r, col: c, letter }); currentPath.push(startCell);
                updateCurrentWordDisplay();
            } else { isDragging = false; }
        };

        const handleDragMove = (event) => {
            if (!isDragging || !isGameRunning) return;
            if (event.cancelable && event.type.startsWith('touch')) event.preventDefault();

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const currentCell = getCellFromPoint(clientX, clientY);
            if (!currentCell || !currentCell.dataset.letter) return;

            const r = parseInt(currentCell.dataset.row), c = parseInt(currentCell.dataset.col), letter = currentCell.dataset.letter;
            const lastSelection = currentSelection.length > 0 ? currentSelection[currentSelection.length - 1] : null;
            if (lastSelection && lastSelection.row === r && lastSelection.col === c) return; // Hovering on last

            const existingIndex = currentSelection.findIndex(item => item.row === r && item.col === c);
            const lastCell = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;

            if (existingIndex !== -1) { // Already in path
                if (currentSelection.length > 1 && existingIndex === currentSelection.length - 2) { // Backtracking
                    currentSelection.pop(); currentPath.pop(); updateCurrentWordDisplay();
                } return;
            }
            if (lastCell && areCellsAdjacent(lastCell, currentCell)) { // Add adjacent
                currentSelection.push({ row: r, col: c, letter }); currentPath.push(currentCell); updateCurrentWordDisplay();
            }
        };

        const handleDragEnd = () => {
            if (!isDragging || !isGameRunning) return;
            isDragging = false;
            if (currentSelection.length >= 3) submitWord();
            else clearSelection();
        };

        // --- Game Logic ---
        const clearSelection = () => {
            currentSelection = []; currentPath = [];
            updateCurrentWordDisplay();
        };

        const flashGrid = (type) => {
            const className = type === 'success' ? 'flash-success' : 'flash-error';
            gridContainer.classList.add(className);
            setTimeout(() => gridContainer.classList.remove(className), 350); // Duration of flash
        };

        const validateWord = async (word) => {
            if (!word || word.length < 3) return false;
            submitWordButton.disabled = true; resetCurrentGameButton.disabled = true; // Disable buttons during check
            submitWordButton.textContent = 'Checking...'; messageArea.textContent = '';

            try {
                const response = await fetch(DICTIONARY_API_URL + word.toUpperCase());
                if (response.ok) return true;
                if (response.status === 404) return false;
                // Handle API errors
                const errorData = await response.json().catch(() => ({ title: response.statusText || 'Unknown API error' }));
                flashMessage(`API Error: ${errorData.title}`, "error"); return false;
            } catch (error) {
                flashMessage("Network error. Check connection.", "error"); return false;
            } finally {
                submitWordButton.textContent = 'Submit Word';
                resetCurrentGameButton.disabled = false; // Re-enable reset
                // submit button state set by clearSelection -> updateCurrentWordDisplay later
            }
        };

        const calculateScore = (len) => len < 3 ? 0 : (SCORE_MAP[Math.min(len, 8)] || 0);

        const submitWord = async () => {
            const word = currentSelection.map(item => item.letter).join('');
            const displayWord = word.replace(/Q/g, 'QU');

            if (word.length < 3) { flashMessage("Word must be >= 3 letters.", "error"); clearSelection(); return; }
            if (foundWords.has(displayWord)) { flashMessage(`Already found: ${displayWord}`, "warning"); clearSelection(); return; }

            const isValid = await validateWord(word);

            if (isValid) {
                flashGrid('success'); // Green flash
                const wordScore = calculateScore(word.length);
                score += wordScore; foundWords.add(displayWord);
                scoreDisplay.textContent = score;
                addWordToList(displayWord, wordScore);
                wordCountDisplay.textContent = foundWords.size;
                flashMessage(`+${wordScore} for ${displayWord}!`, "success");
            } else {
                flashGrid('error'); // Red flash
                // Show "not valid" only if no API/Network error was already shown by validateWord
                if (!messageArea.textContent.includes("API Error") && !messageArea.textContent.includes("Network error")) {
                   flashMessage(`"${displayWord}" is not valid.`, "error");
                }
            }
            clearSelection(); // Clear selection after attempt
        };

        const addWordToList = (word, score) => {
            const li = document.createElement('div');
            li.className = 'flex justify-between items-center p-1 bg-gray-50 rounded border-b border-gray-200';
            li.innerHTML = `<span class="font-medium text-gray-800">${word}</span><span class="text-sm font-bold text-green-600">+${score}</span>`;
            foundWordsList.insertBefore(li, foundWordsList.firstChild);
        };

        const startTimer = () => {
            clearInterval(timerInterval);
            timeLeft = timeLimit; timerDisplay.textContent = timeLeft;
            timerDisplay.classList.remove('text-red-600');
            timerInterval = setInterval(() => {
                timeLeft--; timerDisplay.textContent = timeLeft;
                if (timeLeft <= 10 && timeLeft > 0) timerDisplay.classList.add('text-red-600');
                if (timeLeft <= 0) endGame();
            }, 1000);
        };

        const endGame = () => {
            clearInterval(timerInterval);
            isGameRunning = false; isDragging = false;
            flashMessage(`Time's up! Final Score: ${score}`, "info", 5000);
            setButtonStates(false); // Set buttons for non-running state
            startGameButton.textContent = "Play Again";
            gridContainer.classList.remove('game-running');
            cells.forEach(cell => cell.classList.remove('game-running'));
            clearSelection();
        };

        // Helper to set button/settings disabled state based on game running status
        const setButtonStates = (running) => {
             isGameRunning = running;
             startGameButton.disabled = running;
             submitWordButton.disabled = !running || currentSelection.length < 3; // Also depends on selection
             resetCurrentGameButton.disabled = false; // Always enabled unless mid-API check
             clearBoardButton.disabled = false;      // Always enabled
             settingsArea.querySelectorAll('input, button').forEach(el => el.disabled = running);
             startGameButton.textContent = running ? "Game Running" : "Start Game";
        };


        const startGame = () => {
            if (isGameRunning) return;
            score = 0; foundWords.clear(); clearSelection();
            scoreDisplay.textContent = '0'; foundWordsList.innerHTML = '';
            wordCountDisplay.textContent = '0'; messageArea.textContent = '';
            timerDisplay.classList.remove('text-red-600');
            populateGrid(); // Fill grid (respecting existing letters)
            startTimer();
            setButtonStates(true); // Set buttons for running state
        };

        // Reset score/timer/words, keep board letters
        const resetCurrentBoardState = () => {
            clearInterval(timerInterval); isDragging = false;
            score = 0; foundWords.clear();
            scoreDisplay.textContent = '0';
            timerDisplay.textContent = timeLimit; timerDisplay.classList.remove('text-red-600');
            foundWordsList.innerHTML = ''; wordCountDisplay.textContent = '0';
            messageArea.textContent = ''; messageArea.style.opacity = 1;
            clearSelection(); // Clears path highlights & updates buttons via updateCurrentWordDisplay
            gridContainer.classList.remove('game-running', 'flash-success', 'flash-error');
            cells.forEach(cell => cell.classList.remove('game-running'));
            setButtonStates(false); // Set buttons for non-running state
        };

        // Clear everything back to initial input state
        const clearBoardCompletely = () => {
            clearInterval(timerInterval); isDragging = false;
            score = 0; foundWords.clear(); currentSelection = []; currentPath = []; gridLetters = [];
            scoreDisplay.textContent = '0'; timerDisplay.textContent = timeLimit;
            timerDisplay.classList.remove('text-red-600'); foundWordsList.innerHTML = '';
            wordCountDisplay.textContent = '0'; currentWordDisplay.textContent = '';
            messageArea.textContent = ''; messageArea.style.opacity = 1;
            createGrid(); // Recreate grid with inputs
            setButtonStates(false); // Set buttons for non-running state
        };

        const flashMessage = (message, type = "info", duration = 2500) => {
             clearTimeout(messageTimeout);
             messageArea.textContent = message;
             messageArea.className = 'text-center font-medium mb-4 h-6'; // Reset classes
             if (type === 'error') messageArea.classList.add('text-red-600');
             else if (type === 'success') messageArea.classList.add('text-green-600');
             else if (type === 'warning') messageArea.classList.add('text-yellow-600');
             else messageArea.classList.add('text-blue-600'); // Info
             messageArea.style.opacity = 1;
             messageTimeout = setTimeout(() => { messageArea.style.opacity = 0; }, duration);
        };

        // --- Event Listeners ---
        applySettingsButton.addEventListener('click', () => {
            if (isGameRunning) { flashMessage("Apply settings after game or clear board.", "info"); return; }
            const newSize = parseInt(gridSizeInput.value);
            const newTime = parseInt(timeLimitInput.value);
            let changed = false;
            if (newSize >= 3 && newSize <= 6 && gridSize !== newSize) { gridSize = newSize; changed = true; }
            else if (newSize < 3 || newSize > 6) { gridSizeInput.value = gridSize; flashMessage("Grid size: 3-6.", "warning"); }
            if (newTime >= 10 && timeLimit !== newTime) { timeLimit = newTime; changed = true; }
            else if (newTime < 10) { timeLimitInput.value = timeLimit; flashMessage("Time limit >= 10s.", "warning"); }
            if (changed) { clearBoardCompletely(); flashMessage("Settings applied. Board cleared.", "success"); }
        });

        startGameButton.addEventListener('click', startGame);
        submitWordButton.addEventListener('click', submitWord);
        resetCurrentGameButton.addEventListener('click', resetCurrentBoardState);
        clearBoardButton.addEventListener('click', clearBoardCompletely);
        gridContainer.addEventListener('click', handleCellClick);

        // Drag Listeners
        gridContainer.addEventListener('mousedown', handleDragStart);
        gridContainer.addEventListener('touchstart', handleDragStart, { passive: false });
        bodyElement.addEventListener('mousemove', handleDragMove);
        bodyElement.addEventListener('touchmove', handleDragMove, { passive: false });
        bodyElement.addEventListener('mouseup', handleDragEnd);
        bodyElement.addEventListener('touchend', handleDragEnd);
        bodyElement.addEventListener('touchcancel', handleDragEnd);

        // --- Initial Setup ---
        clearBoardCompletely(); // Start clean

    </script>

</body>
</html>
